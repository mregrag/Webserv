/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Client.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mregrag <mregrag@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/10 17:36:21 by mregrag           #+#    #+#             */
/*   Updated: 2025/04/30 20:59:06 by mregrag          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/Client.hpp"
#include "../include/Logger.hpp"
#include "../include/HTTPRequest.hpp"
#include "../include/HTTPResponse.hpp"
#include "../include/Utils.hpp"
#include "../include/webserver.hpp"



Client::Client(int fd_client, ServerConfig* server) : 
	_fd(fd_client),
	_server(server),
	_bytesSent(0),
	_request(new HTTPRequest(this)),
	_response(new HTTPResponse(this))
{
	_lastActivity = time(NULL);
	LOG_DEBUG("Client created (fd: " + Utils::toString(_fd) + ")");
}

Client::Client(const Client& other): 
	_fd(other._fd),
	_server(other._server),
	_bytesSent(other._bytesSent),
	_lastActivity(other._lastActivity),
	_readBuffer(other._readBuffer),
	_writeBuffer(other._writeBuffer),
	_request(new HTTPRequest(*(other._request))),
	_response(new HTTPResponse(*(other._response)))
{
}

Client::~Client()
{
	delete _request;
	delete _response;
	LOG_DEBUG("Client destroyed (fd: " + Utils::toString(_fd) + ")");
}

Client& Client::operator=(const Client& other)
{
	if (this != &other)
	{
		delete _request;
		delete _response;

		_fd = other._fd;
		_server = other._server;
		_bytesSent = other._bytesSent;
		_lastActivity = other._lastActivity;
		_readBuffer = other._readBuffer;
		_writeBuffer = other._writeBuffer;

		_request = new HTTPRequest(*(other._request));
		_response = new HTTPResponse(*(other._response));
	}
	return *this;
}

void Client::handleRequest() 
{
	LOG_DEBUG("[handleRequest] Handling request from client " + Utils::toString(_fd));

	char buffer[BUFFER_SIZE + 1];
	int bytesRead = 0;

	// Read in a loop for edge-triggered epoll
	while (true) 
	{
		memset(buffer, 0, BUFFER_SIZE + 1);
		bytesRead = recv(_fd, buffer, BUFFER_SIZE, 0);

		if (bytesRead > 0) 
		{
			LOG_DEBUG("[handleRequest] Received " + Utils::toString(bytesRead) + " bytes");
			_readBuffer.append(buffer, bytesRead);

			// For large requests, start parsing immediately
			if (_readBuffer.size() > BUFFER_SIZE) 
			{
				_request->parse(_readBuffer);

				// If we got an error status, we can stop
				if (_request->getStatusCode() != 0) 
				{
					_readBuffer.clear();
					break;
				}

				// If body is complete, we can stop
				if (_request->getState() == HTTPRequest::FINISH) 
				{
					_readBuffer.clear();
					break;
				}
			}
		} 
		else if (bytesRead < 0) 
		{
			// EAGAIN/EWOULDBLOCK means no more data to read right now
			if (errno == EAGAIN || errno == EWOULDBLOCK)
				break;

			throw std::runtime_error("Error with recv function: " + std::string(strerror(errno)));
		} 
		else if (bytesRead == 0) 
		{
			// Client closed connection
			throw std::runtime_error("Client closed connection");
		}
	}

	// Final parse of received data if we didn't already finish
	if (_request->getState() != HTTPRequest::FINISH && _request->getStatusCode() == 0) 
	{
		_request->parse(_readBuffer);
	}

	// Clear buffer if request is complete or there was an error
	if (_request->getState() == HTTPRequest::FINISH || _request->getStatusCode() != 0) 
	{
		_readBuffer.clear();
	}

	LOG_DEBUG("[handleRequest] Current request state: " + Utils::toString(_request->getState()));
}

void Client::prepareResponse() 
{
	if (_request->getState() != HTTPRequest::FINISH && _request->getStatusCode() == 0) 
	{
		LOG_DEBUG("Cannot prepare response: Request not complete");
		return;
	}

	// Build the response and put it in the write buffer
	if (_response->buildResponse() == -1) 
	{
		LOG_DEBUG("Response build failed");
		return;
	}

	_writeBuffer = _response->getResponse();
	_bytesSent = 0;

	LOG_DEBUG("Response prepared, length: " + Utils::toString(_writeBuffer.size()) + " bytes");
}

bool Client::continueResponse() 
{
	if (_writeBuffer.empty()) 
	{
		LOG_DEBUG("Write buffer is empty");
		return true;  // Nothing to send
	}

	// Get remaining data to send
	size_t remainingBytes = _writeBuffer.size() - _bytesSent;
	if (remainingBytes == 0) 
	{
		LOG_DEBUG("All data sent");
		return true;  // All sent
	}

	// Send in a loop for edge-triggered epoll
	while (_bytesSent < _writeBuffer.size()) 
	{
		const char* data = _writeBuffer.c_str() + _bytesSent;
		int sentBytes = send(_fd, data, _writeBuffer.size() - _bytesSent, 0);

		if (sentBytes > 0) 
		{
			_bytesSent += sentBytes;
			LOG_DEBUG("Sent " + Utils::toString(sentBytes) + " bytes, total: " + 
					Utils::toString(_bytesSent) + "/" + Utils::toString(_writeBuffer.size()));

			// Check if we're done
			if (_bytesSent >= _writeBuffer.size()) 
			{
				LOG_DEBUG("Response fully sent to client " + Utils::toString(_fd));
				_writeBuffer.clear();
				_bytesSent = 0;
				return true;
			}
		} 
		else if (sentBytes < 0) 
		{
			// EAGAIN/EWOULDBLOCK means the socket buffer is full
			if (errno == EAGAIN || errno == EWOULDBLOCK) 
			{
				LOG_DEBUG("Socket buffer full, will resume later");
				return false;
			}

			throw std::runtime_error("Error with send function: " + std::string(strerror(errno)));
		}
	}

	return true;  // All sent
}

void Client::reset()
{
	LOG_DEBUG("Resetting client (fd: " + Utils::toString(_fd) + ")");
	delete _request;
	_request = new HTTPRequest(this);
	delete _response;
	_response = new HTTPResponse(this);
	clearBuffers();
}

int Client::getFd() const
{
	return _fd;
}

time_t Client::getLastActivity() const
{
	return _lastActivity;
}

void Client::updateActivity()
{
	_lastActivity = time(NULL);
}

ServerConfig* Client::getServer() const
{
	return _server;
}

const std::string& Client::getWriteBuffer() const
{
	return _writeBuffer;
}

std::string& Client::getWriteBuffer()
{
	return _writeBuffer;
}

const std::string& Client::getReadBuffer() const
{
	return _readBuffer;
}

size_t& Client::getBytesSent()
{
	return _bytesSent;
}

HTTPRequest* Client::getRequest()
{
	return _request;
}

HTTPResponse* Client::getResponse()
{
	return _response;
}

void Client::clearBuffers()
{
	_readBuffer.clear();
	_writeBuffer.clear();
	_bytesSent = 0;
}

